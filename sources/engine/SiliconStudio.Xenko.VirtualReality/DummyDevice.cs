using SiliconStudio.Core.Mathematics;
using SiliconStudio.Xenko.Games;
using SiliconStudio.Xenko.Graphics;

namespace SiliconStudio.Xenko.VirtualReality
{
    public class DummyDevice : VRDevice
    {
        private const float HalfIpd = 0.06f;

        public override Size2 OptimalRenderFrameSize => new Size2(2160, 1200);

        public override Size2 ActualRenderFrameSize { get; protected set; }

        public override Texture MirrorTexture { get; protected set; }

        public override float RenderFrameScaling { get; set; }

        public override DeviceState State => DeviceState.Valid;

        public override Vector3 HeadPosition => Vector3.Zero;

        public override Quaternion HeadRotation => Quaternion.Identity;

        public override Vector3 HeadLinearVelocity => Vector3.Zero;

        public override Vector3 HeadAngularVelocity => Vector3.Zero;

        public override TouchController LeftHand => null;

        public override TouchController RightHand => null;

        public override bool CanInitialize => true;

        public override void Enable(GraphicsDevice device, GraphicsDeviceManager graphicsDeviceManager, bool requireMirror, int mirrorWidth, int mirrorHeight)
        {
            ActualRenderFrameSize = OptimalRenderFrameSize;
            MirrorTexture = Texture.New2D(device, ActualRenderFrameSize.Width, ActualRenderFrameSize.Height, PixelFormat.R8G8B8A8_UNorm_SRgb, TextureFlags.RenderTarget | TextureFlags.ShaderResource);
        }

        public override void ReadEyeParameters(Eyes eye, float near, float far, ref Vector3 cameraPosition, ref Matrix cameraRotation, out Matrix view, out Matrix projection)
        {
            // As generated by Occulus VR
            projection = new Matrix(1.19034183f, 0, 0, 0, 0, 0.999788344f, 0, 0, (eye == Eyes.Left ? -1.0f : 1.0f) * 0.148591548f, -0.110690169f, -1.0001f, -1, 0, 0, -0.10001f, 0);

            // Adjust position from camera to eye
            var eyeLocal = new Vector3((eye == Eyes.Left ? -HalfIpd : HalfIpd) * 0.5f, 0.0f, 0.0f) * ViewScaling;
            Vector3 eyeWorld;
            Vector3.TransformCoordinate(ref eyeLocal, ref cameraRotation, out eyeWorld);
            var pos = cameraPosition + eyeWorld;

            // Transpose ViewMatrix (rotation only, so equivalent to inversing it)
            Matrix.Transpose(ref cameraRotation, out view);

            // Rotate our translation so that we can inject it in the view matrix directly
            Vector3.TransformCoordinate(ref pos, ref view, out pos);

            // Apply inverse of translation (equivalent to opposite)
            view.TranslationVector = -pos;
        }

        public override void Commit(CommandList commandList, Texture renderFrame)
        {
            commandList.Copy(renderFrame, MirrorTexture);
        }

        public override void Update(GameTime gameTime)
        {
            //nothing needed
        }

        public override void Draw(GameTime gameTime)
        {
            //nothing needed
        }
    }
}