// Copyright (c) 2014-2017 Silicon Studio Corp. All rights reserved. (https://www.siliconstudio.co.jp)
// See LICENSE.md for full license information.

shader CarPaintCommon
{
    #define CAR_PAINT_PROCEDURAL
    
    // Helpers
    inline float UIntToFloat(in uint x) { return ((int)x) - ((x < 0) ? 1 : 0); }
    inline uint FloatToUInt(in float x) { return (x * (1.0f / (float)0xFFFFFFFF)); }

    //------------------------------------------------------------------------------
    // Generate hash
    //------------------------------------------------------------------------------
    uint hash(uint kx, uint ky, uint kz)
    {
        // define some handy macros
        #define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))
        #define final(a,b,c) \
        { \
        c ^= b; c -= rot(b,14); \
        a ^= c; a -= rot(c,11); \
        b ^= a; b -= rot(a,25); \
        c ^= b; c -= rot(b,16); \
        a ^= c; a -= rot(c,4);  \
        b ^= a; b -= rot(a,14); \
        c ^= b; c -= rot(b,24); \
        }
        // now hash the data!
        uint a, b, c, len = 3;
        a = b = c = 0xdeadbeef + (len << 2) + 13;

        c += kz;
        b += ky;
        a += kx;
        final(a, b, c);

        return c;
        // macros not needed anymore
        #undef rot
        #undef final
    }

    //------------------------------------------------------------------------------
    // Generate cellnoise value from 3D vector
    //------------------------------------------------------------------------------
    float cellnoise_scalar(float3 p)
    {
        uint ix = FloatToUInt(p.x);
        uint iy = FloatToUInt(p.y);
        uint iz = FloatToUInt(p.z);

        return UIntToFloat(hash(ix, iy, iz));
    }

    //------------------------------------------------------------------------------
    // Generate cellnoise vector from 3D vector
    //------------------------------------------------------------------------------
    float3 cellnoise(float3 p)
    {
        float r = cellnoise_scalar(p);
        float g = cellnoise_scalar(p.yxz);
        float b = cellnoise_scalar(p.yzx);

        return float3(r,g,b);
    }

    //------------------------------------------------------------------------------
    // Internal function for flake generation
    //------------------------------------------------------------------------------
    int check_flake_cell(float3 b, float3 position, float flake_size, float flake_size_variance, out float3 cell_center)
    {
        const float safe_flake_size_variance = clamp(flake_size_variance, 0.1, 1.0);
        float3 cellCenters[9] = {
            float3( 0.5,  0.5,  0.0),
            float3( 1.5,  0.5,  0.0),
            float3( 1.5,  1.5,  0.0),
            float3( 0.5,  1.5,  0.0),
            float3(-0.5,  1.5,  0.0),
            float3(-0.5,  0.5,  0.0),
            float3(-0.5, -0.5,  0.0),
            float3( 0.5, -0.5,  0.0),
            float3( 1.5, -0.5,  0.0)
        };

        float3 nearestCell = float3(0.0, 0.0, 1.0);
        int nearestCellIndex = -1;
        for(int cellIndex = 0; cellIndex < 9; ++cellIndex)
        {
            float3 cellCenter = b + cellCenters[cellIndex];

            float3 centerOffset = cellnoise(cellCenter) * 2.0 - 1.0;
            centerOffset.z *= safe_flake_size_variance;
            centerOffset = normalize(centerOffset);

            cellCenter += 0.5 * centerOffset;

            float cellDistance = distance(position, cellCenter);
            if(cellDistance < flake_size && cellCenter.z < nearestCell.z)
            {
                nearestCell      = cellCenter;
                nearestCellIndex = cellIndex;
            }
        }

        cell_center = cellCenters[nearestCellIndex];
        return nearestCellIndex;
    }

    void GenerateFlakeCellData(in float3 scaledCellPosition, in float flakeSize, out float3 noiseGenerationPosition, in float flakeSizeVariance, out int nearestCellIndex )
    {
        float3 baseCellPosition = floor(scaledCellPosition);
        float3 cellCenter = float3(0.0f, 0.0f, 0.0f);
       
        // Get the cell index
        nearestCellIndex = check_flake_cell(baseCellPosition, scaledCellPosition, flakeSize, flakeSizeVariance, cellCenter);

        // 3D vector used to generate cell noise
        noiseGenerationPosition = baseCellPosition + cellCenter;
    }

    float3 GenerateRandomFlakeColor(in float4 p, in float3 baseColor, in float2 uv)
    {
        const float flake_scale              = p.x;
        const float flake_size               = p.y;
        const float flake_size_variance      = p.z;
        const float pearlescent_ratio        = p.w;

        float3 scaledCellPosition = float3(uv.x, uv.y, 0.0) * flake_scale;
        float3 noiseGenerationPosition = float3(0.0f, 0.0f, 0.0f);
        int nearestCellIndex = -1;
        GenerateFlakeCellData(scaledCellPosition, flake_size, nearestCellIndex, flake_size_variance, noiseGenerationPosition);

        if (nearestCellIndex >= 0)
        {
            float3 randomValues = cellnoise(noiseGenerationPosition + float3(1.0, 2.0, 3.5));
            float3 randomColor  = cellnoise(noiseGenerationPosition + float3(2.0, 1.0, 0.5));

            return lerp(randomColor, baseColor.xyz, step(pearlescent_ratio, randomValues.x));
        }

        return baseColor;
    }

    float3 GenerateRandomFlakeNormal(in float4 p, in float3 baseNormal, in float2 uv)
    {
        const float flake_scale              = p.x;
        const float flake_size               = p.y;
        const float flake_size_variance      = p.z;
        
        float3 scaledCellPosition = float3(uv.x, uv.y, 0.0) * flake_scale;
        float3 noiseGenerationPosition = float3(0.0f, 0.0f, 0.0f);
        int nearestCellIndex = -1;
        GenerateFlakeCellData(scaledCellPosition, flake_size, nearestCellIndex, flake_size_variance, noiseGenerationPosition);

        if (nearestCellIndex >= 0)
        {
            float3 randomNormal = cellnoise(noiseGenerationPosition + float3(0.0, 0.0, 1.5));
            randomNormal = 2.0 * randomNormal - 1.0;
            randomNormal = faceforward(randomNormal, float3(0.0, 0.0, 1.0), randomNormal);

            return randomNormal;
        }

        return baseNormal;
    }

    float GenerateRandomFlakeShininess(in float4 p, in float2 uv, in float baseShininess)
    {
        const float flake_scale              = p.x;
        const float flake_size               = p.y;
        const float flake_size_variance      = p.z;
        
        float3 scaledCellPosition = float3(uv.x, uv.y, 0.0) * flake_scale;
        float3 noiseGenerationPosition = float3(0.0f, 0.0f, 0.0f);
        int nearestCellIndex = -1;
        GenerateFlakeCellData(scaledCellPosition, flake_size, nearestCellIndex, flake_size_variance, noiseGenerationPosition);

        if (nearestCellIndex >= 0)
        {      
            return cellnoise(noiseGenerationPosition + float3(1.0, 2.0, 3.5)).y;
        }

        return baseShininess;
    }
};
