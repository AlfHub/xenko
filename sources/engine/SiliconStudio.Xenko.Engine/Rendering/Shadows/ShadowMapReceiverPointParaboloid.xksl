// Copyright (c) 2016 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Xenko.Rendering.Shadows
{
    /// <summary>
    /// Selects the shadow map and computes the shadow factor.
    /// </summary>
    internal shader ShadowMapReceiverPointParaboloid<int TLightCount> : ShadowMapGroup<PerDraw.Lighting>, ShadowMapFilterBase<PerDraw.Lighting>, PositionStream4, ShaderBaseStream
    {
        cbuffer PerDraw.Lighting
        {
            float4x4 View[TLightCount];
            float2 FaceOffset[TLightCount];
            float2 BackfaceOffset[TLightCount];
            float BackfaceMode[TLightCount];
            float2 FaceSize[TLightCount];
            float DepthBiases[TLightCount];
            float2 DepthParameters[TLightCount];
        };
        
        override void ComputeShadow(int lightIndex)
        {
            float4 lightSpace = mul(float4(streams.PositionWS.xyz, 1), View[lightIndex]);
            
            // Store length and normalize
            float z = length(lightSpace.xyz);
            float3 intermediate = lightSpace.xyz / z;
            
            // Project x/y coordinates on parabola
            intermediate.xy /= 1.0f + abs(intermediate.z);
            
            float2 depthParameters = DepthParameters[lightIndex];
            float projectedDepth = z * depthParameters.y;

            // Map from (-1,1) to (0,1)
            intermediate.xy = intermediate.xy * 0.5 + float2(0.5, 0.5);

            // Apply offset into atlas and size of a single face in the atlas
            float2 samplePosition = intermediate.xy * FaceSize[lightIndex] + FaceOffset[lightIndex];

            float shadowMultiplier = 1;
            [flatten]
            if(lightSpace.z < 0)
            {
                samplePosition += BackfaceOffset[lightIndex];
                if(BackfaceMode[lightIndex] == 0)
                {
                    // Basically ignore shadow by multiplying with 0 conditionally, but preventing a branch on the texture sampler
                    samplePosition = 0;
                    shadowMultiplier = 0;
                }
            }
            
            streams.shadowColor = FilterShadow(samplePosition, projectedDepth - DepthBiases[lightIndex]) * shadowMultiplier + (1-shadowMultiplier);
        }
    };
}