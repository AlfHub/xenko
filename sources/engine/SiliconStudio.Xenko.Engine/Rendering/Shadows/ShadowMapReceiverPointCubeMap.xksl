// Copyright (c) 2016 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Xenko.Rendering.Shadows
{
    /// <summary>
    /// Selects the shadow map and computes the shadow factor.
    /// </summary>
    internal shader ShadowMapReceiverPointCubeMap<int TLightCount> : MaterialPixelShadingStream, ShadowMapGroup<PerDraw.Lighting>, ShadowMapFilterBase<PerDraw.Lighting>, PositionStream4
    {
        cbuffer PerDraw.Lighting
        {
            float4x4 WorldUvMatrices[TLightCount*6];
			float4 LightPosition[TLightCount];
			// Offsets for every light, for every face
            float2 LightFaceOffsets[TLightCount*6];
            float2 LightFaceSize[TLightCount];
            float2 LightDepthParameters[TLightCount];
            float DepthBiases[TLightCount];
        };
		
		// Projects depth into the depth buffer space
		stage float ProjectDepth(int lightIndex, float depth)
        {
            return LightDepthParameters[lightIndex].y / depth + LightDepthParameters[lightIndex].x;
        }

        override void ComputeShadow(int lightIndex)
        {
            // TODO: This already gets computed for lighting, so it's calculated a second time here while it should not be
            float3 delta = streams.PositionWS.xyz - LightPosition[lightIndex].xyz;
			float3 direction = normalize(delta);
			float3 dirAbs = abs(direction);
			
			float longestAxis = max(dirAbs.x, max(dirAbs.y, dirAbs.z));

			int faceIndex;
			float3 str;

			[flatten]
			if(dirAbs.x == longestAxis)
			{
				str = float3(direction.z, direction.y, delta.x);
				faceIndex = 2;
			}
			else if(dirAbs.y == longestAxis)
			{
				str = float3(direction.x, direction.z, delta.y);
				faceIndex = 4;
			}
			else // direction.z == longestAxis
			{
				str = float3(direction.x, direction.y, delta.z);
				faceIndex = 0;
			}
			
			// Offset the negative side of a direction
			faceIndex += int(max(0, -sign(str.z)));
			str.z = abs(str.z);

			float absLongest = abs(longestAxis);
			str.xy = str.xy / float2(absLongest, absLongest);
			str.xy += float2(1, 1);
			str.xy *= 0.5;

			float2 textureOffset = LightFaceOffsets[lightIndex*6+faceIndex] + str.xy * LightFaceSize[lightIndex];
            
			float projectedDepth = ProjectDepth(lightIndex, str.z);

            float2 gradient = 0;
            if (false /*TODO: if GradientShadowMap*/)
            {
                float4x4 worldUv = WorldUvMatrices[lightIndex*6+faceIndex];
                float3 normal = streams.normalWS;

                float3 pstart1 = worldUv[0].xyz;
                float3 pstart2 = worldUv[1].xyz;
                float3 ldirWS = worldUv[2].xyz;

                // intersect light dir ray to geometry:
                float t2 = -dot(normal, pstart2) / dot(normal, ldirWS);
                float3 p2 = pstart2 + ldirWS * t2;
                
                float t1 = -dot(normal, pstart1) / dot(normal, ldirWS);
                float3 p1 = pstart1 + ldirWS * t1;
                
                // Project new depths
                float z2 = ProjectDepth(lightIndex, t2);
                float z1 = ProjectDepth(lightIndex, t1);
                gradient = float2(z1 - projectedDepth, z2 - projectedDepth);
                
                // limit problems of degenerate cases (vertical walls when light is vertical):
                //gradient = min(float2(0.1, 0.1), gradient);
            }

            streams.shadowColor = FilterShadow(textureOffset, projectedDepth, gradient);
        }
    };
}