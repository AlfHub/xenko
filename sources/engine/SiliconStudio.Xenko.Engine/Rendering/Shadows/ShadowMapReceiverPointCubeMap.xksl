// Copyright (c) 2016 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Xenko.Rendering.Shadows
{
    /// <summary>
    /// Selects the shadow map and computes the shadow factor.
    /// </summary>
    internal shader ShadowMapReceiverPointCubeMap<int TLightCount> : MaterialPixelShadingStream, ShadowMapGroup<PerDraw.Lighting>, ShadowMapFilterBase<PerDraw.Lighting>, PositionStream4
    {
        cbuffer PerDraw.Lighting
        {
            float4x4 ViewProjection[TLightCount*6];
            float4x4 InverseViewProjection[TLightCount*6];
            float4x4 ProjectionToShadow[TLightCount*6];
			float4 LightPosition[TLightCount];
            float DepthBiases[TLightCount];
            float DirectionOffset[TLightCount];
        };

        override void ComputeShadow(int lightIndex)
        {
            // TODO: This already gets computed for lighting, so it's calculated a second time here while it should not be
            float3 lightPosition = LightPosition[lightIndex].xyz;
            float3 delta = streams.PositionWS.xyz - lightPosition;
			float3 direction = normalize(delta);
			float3 dirAbs = abs(direction);
			
			float longestAxis = max(dirAbs.x, max(dirAbs.y, dirAbs.z));

			int faceIndex;
			float3 str;

			[flatten]
			if(dirAbs.x == longestAxis)
			{
				str = float3(direction.z, direction.y, delta.x);
				faceIndex = 2;
			}
			else if(dirAbs.y == longestAxis)
			{
				str = float3(direction.x, direction.z, delta.y);
				faceIndex = 4;
			}
			else // direction.z == longestAxis
			{
				str = float3(direction.x, direction.y, delta.z);
				faceIndex = 0;
			}
			
			// Offset the negative side of a direction
			faceIndex += int(max(0, -sign(str.z)));

            float4x4 viewProjection = ViewProjection[lightIndex*6+faceIndex];
            float4x4 invViewProjection = InverseViewProjection[lightIndex*6+faceIndex];
            float4x4 toShadow = ProjectionToShadow[lightIndex*6+faceIndex];

            float4 projectedPosition = mul(streams.PositionWS, viewProjection);
            projectedPosition /= projectedPosition.w;

			//str.z = abs(str.z);
			//float absLongest = abs(longestAxis);
			//str.xy = str.xy / float2(absLongest, absLongest);
			//str.xy += float2(1, 1);
			//str.xy *= 0.5;

			//float projectedDepth = ProjectDepth(lightIndex, str.z);
			//float2 textureOffset = LightFaceOffsets[lightIndex*6+faceIndex] + str.xy * LightFaceSize[lightIndex];
            
            float2 gradient = 0;
            if (true /*TODO: if GradientShadowMap*/)
            {
                float projectedOffset = DirectionOffset[lightIndex];
                float4 pointRight = float4(projectedPosition.x + projectedOffset, projectedPosition.y, 0, 1);
                pointRight = mul(pointRight, invViewProjection);
                float3 rayRight = normalize(pointRight.xyz / pointRight.w - lightPosition);

                float4 pointUp = float4(projectedPosition.x, projectedPosition.y - projectedOffset, 0, 1);
                pointUp = mul(pointUp, invViewProjection);
                float3 rayUp = normalize(pointUp.xyz / pointUp.w - lightPosition);
                
                float3 normal = streams.normalWS;

                float t1 = dot(delta, normal) / dot(normal, rayRight);
                float3 p1 = lightPosition + rayRight * t1;
                
                // intersect light dir ray to geometry:
                float t2 = dot(delta, normal) / dot(normal, rayUp);
                float3 p2 = lightPosition + rayUp * t2;
                
                float4 z1 = mul(float4(p1,1), viewProjection);
                z1 /= z1.w;
                float4 z2 = mul(float4(p2,1), viewProjection);
                z2 /= z2.w;

                // Project new depths
                // * ShadowMapTextureSize
                gradient = float2(z1.z - projectedPosition.z, z2.z - projectedPosition.z) * ShadowMapTextureSize;
                
                // limit problems of degenerate cases (vertical walls when light is vertical):
                //gradient = min(float2(0.1, 0.1), gradient);
                streams.shadowColor = float3(gradient.xy,0);
            }

            // Reproject world position but with bias
            float3 biasedWorldPosition = streams.PositionWS + direction * -DepthBiases[lightIndex];
            projectedPosition = mul(float4(biasedWorldPosition, 1), viewProjection);
            projectedPosition /= projectedPosition.w;

            float4 uvPos = mul(projectedPosition, toShadow);
            streams.shadowColor = FilterShadow(uvPos.xy, uvPos.z, gradient);
            //float2 n = (uvPos.xy-LightFaceOffsets[faceIndex])/LightFaceSize[faceIndex];
            //streams.shadowColor = float3(gradient.xy, 0);
            //streams.shadowColor = invViewMatrix[2].xyz;
        }
    };
}