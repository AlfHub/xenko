// Copyright (c) 2016 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Xenko.Rendering.Shadows
{
    /// <summary>
    /// Selects the shadow map and computes the shadow factor.
    /// </summary>
    internal shader ShadowMapReceiverPointCubeMap<int TLightCount> : ShadowMapGroup<PerDraw.Lighting>, ShadowMapFilterBase<PerDraw.Lighting>, PositionStream4, ShaderBaseStream, LightStream
    {
        cbuffer PerDraw.Lighting
        {
            float4x4 WorldToShadow[TLightCount*6];
            float DepthBiases[TLightCount];
            float2 DepthParameters[TLightCount];
        };

        override void ComputeShadow(int lightIndex)
        {
            // TODO: This already gets computed for lighting, so it's calculated a second time here while it should not be
            float3 lightPosition = streams.lightPositionWS.xyz;
            float3 delta = streams.PositionWS.xyz - lightPosition;
            float l = length(delta);
            float3 direction = delta / l;
            float3 dirAbs = abs(direction);
            
            float longestAxis = max(dirAbs.x, max(dirAbs.y, dirAbs.z));

            int faceIndex;
            float z;
            
            // Select the base face index for either X,Y or Z facing
            [flatten]
            if(dirAbs.x == longestAxis)
            {
                z = delta.x;
                faceIndex = 2;
            }
            else if(dirAbs.y == longestAxis)
            {
                z = delta.y;
                faceIndex = 4;
            }
            else // direction.z == longestAxis
            {
                z = delta.z;
                faceIndex = 0;
            }
            
            // Apply offset the negative side of a direction (+1)
            float sz = sign(z);
            faceIndex += int(-min(0.0, sz));

            // Map to texture space
            float4 projectedPosition = mul(streams.PositionWS, WorldToShadow[lightIndex*6+faceIndex]);
            projectedPosition /= projectedPosition.w;

            // Apply bias
            l -= DepthBiases[lightIndex];

            // Scale distance to light depth buffer range 
            l *= DepthParameters[lightIndex].y;

            streams.shadowColor = FilterShadow(projectedPosition.xy, l, 0);
        }
    };
}