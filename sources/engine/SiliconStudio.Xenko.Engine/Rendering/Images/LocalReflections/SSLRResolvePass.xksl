// Copyright (c) 2017 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Xenko.Rendering.Images
{
    /// <summary>
	/// Screen Space Local Reflections shader for Resolve Pass
    /// </summary>
    shader SSLRResolvePass<int ResolveSamples, bool ReduceFireflies> : ImageEffectShader, SSLRCommon, NormalPack, Math, BRDFMicrofacet
    {
        static const float2 Offsets[8] =
        {
            float2( 0,  0),
            float2( 2, -2),
            float2(-2, -2),
            float2( 0,  2),
            float2(-2,  0),
            float2( 0, -2),
            float2( 2,  0),
            float2( 2,  2),
        };

        override stage float4 Shading()
        {
			// Inputs Mapping:
			// Texture0 - Scene Color (with blurred mip maps chain)
			// Texture1 - Depth
			// Texture2 - World Space Normals
			// Texture3 - Specular Color + Roughness
            // Texture4 - Blue Noise
			// Texture5 - Ray Trace result
			// Texture6 - Ray Trace Mask result

			float2 uv = streams.TexCoord;
			
            if(Texture6.SampleLevel(LinearSampler, uv, 0).r <= 0.001)
                return 0;
            
			// Sample material roughness
			float4 specularRoughnessBuffer = Texture3.SampleLevel(PointSampler, uv, 0);
			float roughness = specularRoughnessBuffer.a;
			
			// Get view space position
			float depth = SampleZ(uv);
			float3 positionVS = ComputeViewPosition(uv, depth);
			
            //if(length(Texture5.SampleLevel(PointSampler, uv, 0).rg) < 0.001f)
            //    return float4(0, 1, 0, 1);

            //return float4(uv, 1, 1);
            //return float4(Texture0.SampleLevel(PointSampler, Texture5.SampleLevel(PointSampler, uv, 0).rg, 0).rgb, 1);
            //return pow(depth.xxxx, 8) / 6;

			// Reject invalid pixels
			if(positionVS.z > 100.0f || roughness > RoughnessFade)
				return 0;

			// Calculate view space normal vector
			float4 normalsBuffer = Texture2.SampleLevel(PointSampler, uv, 0);
			float3 normalWS = DecodeNormal(normalsBuffer.rgb);
			float3 normalVS = mul(normalWS, (float3x3)V);
			
            float3 positionWS = ComputeWorldPosition(uv, depth);
			float3 viewWS = normalize(positionWS - CameraPosWS.xyz);
			float3 reflectWS = reflect(viewWS, normalWS);
			
			// TODO: dont use reflectVS, only reflectWS ??
			
            float2 random = RandN2(uv, Time * UseTemporal);
            
            //return float4(random, 0, 1);

            // Blue noise generated by https://github.com/bartwronski/BlueNoiseGenerator/
            //float2 jitter = Texture4.SampleLevel(LinearSampler, float2(uv + random), 0).rg;
            //float2 jitter = Texture4.SampleLevel(LinearSampler, uv, 0).rg;
            //float2 jitter = random;
		    //float2 Xi = jitter;
		    //Xi.y = lerp(Xi.y, 0.0, BRDFBias);

            float2 blueNoise = random.xy * 2.0 - 1.0; // TODO: use blue noise texture
            //float2 blueNoise = Texture4.SampleLevel(LinearSampler, uv + random, 0).rg * 2.0 - 1.0; // works better with [-1, 1] range

            float2x2 offsetRotationMatrix = float2x2(blueNoise.x, blueNoise.y, -blueNoise.y, blueNoise.x);

            float NdotV = saturate(dot(normalWS, -viewWS));
		    float coneTangent = lerp(0.0, roughness * (1.0 - BRDFBias), pow(NdotV, 1.5) * sqrt(roughness));
		    //float coneTangent = lerp(NdotV * 2.0, 1.0, sqrt(roughness)); // TODO: test this calc version

		    float maxMipLevel = (float)MaxColorMiplevel - 1;// - 1.0;

            float3 vectorV = normalize(-positionVS);

            //return float4(1, 0, 1, 1);

		    float4 result = 0.0;
            for(int i = 0; i < ResolveSamples; i++)
            {
                float2 offsetUV = Offsets[i] * Texture5TexelSize;
                offsetUV =  mul(offsetRotationMatrix, offsetUV);

                // "uv" is the location of the current (or "local") pixel. We want to resolve the local pixel using
                // intersections spawned from neighboring pixels. The neighboring pixel is this one:
                float2 neighborUv = uv + offsetUV;

                // Now we fetch the intersection point and the PDF that the neighbor's ray hit.
                float4 hitPacked = Texture5.SampleLevel(LinearSampler, neighborUv, 0); // TODO: test with PointSampler
                float2 hitUv = hitPacked.xy;
                float hitZ = hitPacked.z;
                float hitPDF = hitPacked.w;
                float hitMask = Texture6.SampleLevel(PointSampler, neighborUv, 0).r;

                float weight = hitMask;

                float intersectionCircleRadius = coneTangent * length(hitUv - uv);
                float mip = clamp(log2(intersectionCircleRadius * TraceSizeMax), 0.0, maxMipLevel); // TODO; rename TraceSizeMax to ResolveSizeMax

                float4 sampleColor = float4(Texture0.SampleLevel(LinearSampler, hitUv, mip).rgb, 1);
                if(ReduceFireflies)
                    sampleColor.rgb /= 1 + Luminance(sampleColor.rgb);

                result += sampleColor * weight;
 
            }
            result /= ResolveSamples;
            if(ReduceFireflies)
			    result.rgb /= 1 - Luminance(result.rgb);
            result.rgb *= result.a;

    	    return max(1e-5, result);
        }
    };

    effect SSLRResolvePassEffect
    {
        using params SSLRKeys;

        mixin SSLRResolvePass<SSLRKeys.ResolveSamples, SSLRKeys.ReduceFireflies>;
    }
}