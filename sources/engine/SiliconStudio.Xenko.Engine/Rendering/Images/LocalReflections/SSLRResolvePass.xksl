// Copyright (c) 2017 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Xenko.Rendering.Images
{
    /// <summary>
	/// Screen Space Local Reflections shader for Resolve Pass
    /// </summary>
    shader SSLRResolvePass<int ResolveSamples> : ImageEffectShader, SSLRCommon, NormalPack, Math, BRDFMicrofacet
    {
        static const float2 Offsets[8] =
        {
            float2( 0,  0),
            float2( 2, -2),
            float2(-2, -2),
            float2( 0,  2),
            float2(-2,  0),
            float2( 0, -2),
            float2( 2,  0),
            float2( 2,  2),
        };

        // Brian Karis, Epic Games "Real Shading in Unreal Engine 4"
        float4 ImportanceSampleGGX(float2 Xi, float Roughness)
        {
	        float m = Roughness * Roughness;
	        float m2 = m * m;
		
	        float Phi = 2 * PI * Xi.x;
				 
	        float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (m2 - 1.0) * Xi.y));
	        float SinTheta = sqrt(max(1e-5, 1.0 - CosTheta * CosTheta));
				 
	        float3 H;
	        H.x = SinTheta * cos(Phi);
	        H.y = SinTheta * sin(Phi);
	        H.z = CosTheta;
		
	        float d = (CosTheta * m2 - CosTheta) * CosTheta + 1;
	        float D = m2 / (PI * d * d);
	        float pdf = D * CosTheta;

	        return float4(H, pdf); 
        }

        float BRDF_Unity_Weight(float3 V, float3 L, float3 N, float Roughness)
        {
            float3 H = normalize(L + V);

            float NdotH = saturate(dot(N,H));
            float NdotL = saturate(dot(N,L));
            float NdotV = saturate(dot(N,V));

            half G = VisibilitySmithGGXCorrelated(Roughness, NdotL, NdotV);
            half D = NormalDistributionGGX(Roughness, NdotH);

            return (D * G) * (PI / 4.0);
        }

        override stage float4 Shading()
        {
			// Inputs Mapping:
			// Texture0 - Scene Color (with blurred mip maps chain)
			// Texture1 - Depth
			// Texture2 - World Space Normals
			// Texture3 - Specular Color + Roughness
            // Texture4 - Blue Noise
			// Texture5 - Ray Trace result
			// Texture6 - Ray Trace Mask result

			float2 uv = streams.TexCoord;
			
            if(Texture6.SampleLevel(LinearSampler, uv, 0).r <= 0.001)
                return 0;
            
			// Sample material roughness
			float4 specularRoughnessBuffer = Texture3.SampleLevel(PointSampler, uv, 0);
			float roughness = specularRoughnessBuffer.a;
			
			// Get view space position
			float depth = SampleZ(uv);
			float3 positionVS = ComputeViewPosition(uv, depth);
			
            //if(length(Texture5.SampleLevel(PointSampler, uv, 0).rg) < 0.001f)
            //    return float4(0, 1, 0, 1);

            //return float4(uv, 1, 1);
            //return float4(Texture0.SampleLevel(PointSampler, Texture5.SampleLevel(PointSampler, uv, 0).rg, 0).rgb, 1);
            //return pow(depth.xxxx, 8) / 6;

			// Reject invalid pixels
			if(positionVS.z > 100.0f || roughness > RoughnessFade)
				return 0;

			// Calculate view space normal vector
			float4 normalsBuffer = Texture2.SampleLevel(PointSampler, uv, 0);
			float3 normalWS = DecodeNormal(normalsBuffer.rgb);
			float3 normalVS = mul(normalWS, (float3x3)V);
			
            float3 positionWS = ComputeWorldPosition(uv, depth);
			float3 viewWS = normalize(positionWS - CameraPosWS.xyz);
			float3 reflectWS = reflect(viewWS, normalWS);
			
			// TODO: dont use reflectVS, only reflectWS ??
			
            float2 random = RandN2(uv, Time * UseTemporal);
            
            //return float4(random, 0, 1);

            // Blue noise generated by https://github.com/bartwronski/BlueNoiseGenerator/
            //float2 jitter = Texture4.SampleLevel(LinearSampler, float2(uv + random), 0).rg;
            //float2 jitter = Texture4.SampleLevel(LinearSampler, uv, 0).rg;
            //float2 jitter = random;
		    //float2 Xi = jitter;
		    //Xi.y = lerp(Xi.y, 0.0, BRDFBias);

            float2 blueNoise = random.xy * 2.0 - 1.0; // TODO: use blue noise texture
            //float2 blueNoise = Texture4.SampleLevel(LinearSampler, uv + random, 0).rg * 2.0 - 1.0; // works better with [-1, 1] range

            float2x2 offsetRotationMatrix = float2x2(blueNoise.x, blueNoise.y, -blueNoise.y, blueNoise.x);

            float NdotV = saturate(dot(normalWS, -viewWS));
		    float coneTangent = lerp(0.0, roughness * (1.0 - BRDFBias), pow(NdotV, 1.5) * sqrt(roughness));
		    //float coneTangent = lerp(NdotV * 2.0, 1.0, sqrt(roughness)); // TODO: test this calc version

		    float maxMipLevel = (float)MaxColorMiplevel;// - 1.0;

            float3 vectorV = normalize(-positionVS);

            //return float4(1, 0, 1, 1);

		    float4 result = 0.0;
            float weightSum = 0.0;	
            for(int i = 0; i < ResolveSamples; i++)
            {
                float2 offsetUV = Offsets[i] * Texture5TexelSize;
                offsetUV =  mul(offsetRotationMatrix, offsetUV);

                // "uv" is the location of the current (or "local") pixel. We want to resolve the local pixel using
                // intersections spawned from neighboring pixels. The neighboring pixel is this one:
                float2 neighborUv = uv + offsetUV;

                // Now we fetch the intersection point and the PDF that the neighbor's ray hit.
                float4 hitPacked = Texture5.SampleLevel(LinearSampler, neighborUv, 0); // TODO: test with PointSampler
                float2 hitUv = hitPacked.xy;
                float hitZ = hitPacked.z;
                float hitPDF = hitPacked.w;
                float hitMask = Texture6.SampleLevel(PointSampler, neighborUv, 0).r;

                float3 hitViewPos = ScreenToView(hitUv, hitZ);

                //return float4(hitViewPos, 1);
                //return float4(hitMask.xxx, 1);

                // We assume that the hit point of the neighbor's ray is also visible for our ray, and we blindly pretend
                // that the current pixel shot that ray. To do that, we treat the hit point as a tiny light source. To calculate
                // a lighting contribution from it, we evaluate the BRDF. Finally, we need to account for the probability of getting
                // this specific position of the "light source", and that is approximately 1/PDF, where PDF comes from the neighbor.
                // Finally, the weight is BRDF/PDF. BRDF uses the local pixel's normal and roughness, but PDF comes from the neighbor.
                //float weight = BRDF_Unity_Weight(vectorV /*V*/, normalize(hitViewPos - positionVS) /*L*/, normalVS /*N*/, roughness) / max(1e-5, hitPDF);
                float weight = 1.0f;
                
                //return float4(weight.xxx, 1);

                float intersectionCircleRadius = coneTangent * length(hitUv - uv);
                float mip = clamp(log2(intersectionCircleRadius * TraceSizeMax), 0.0, maxMipLevel); // TODO; rename TraceSizeMax to ResolveSizeMax

                float4 sampleColor = float4(Texture0.SampleLevel(LinearSampler, hitUv, mip).rgb, 1) * hitMask;
                
                //if(_Fireflies == 1) // TODO: use param for Fireflies
                //    sampleColor.rgb /= 1 + Luminance(sampleColor.rgb);

                result += sampleColor * weight;
                weightSum += weight;
            }
            result /= weightSum;
            result.rgb *= result.a;

		    //if(_Fireflies == 1) // TODO: use param for Fireflies
			//    result.rgb /= 1 - Luminance(result.rgb);

            
    	    return max(1e-5, result);
        }
    };

    effect SSLRResolvePassEffect
    {
        using params SSLRKeys;

        mixin SSLRResolvePass<SSLRKeys.ResolveSamples>;
    }
}