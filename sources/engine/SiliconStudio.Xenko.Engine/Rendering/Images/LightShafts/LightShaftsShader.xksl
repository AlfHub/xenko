// Copyright (c) 2014-2017 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Xenko.Rendering.Images
{
    shader LightShaftsShader : ImageEffectShader, ShadowMapCommon<PerFrame>, PostEffectBoundingRay<0, 0, 16>, LightStream, NormalStream
    {
        stage compose ShadowGroup shadowGroup;
        stage compose LightShaftsAttenuation attenuation;

        cbuffer PerFrame
        {
            // World to shadow matrix
            stage matrix ShadowViewProjection;

            // Shadow map boundary for the current shadow map in the shadow atlas
            stage float4 ShadowTextureFactor;
        
            // Light position (if applicable)
            stage float3 LightPosition;
            // Light direction (if applicable)
            stage float3 LightDirection;

            stage float ExtinctionFactor;
            stage float DensityFactor;

            // Unused
            stage float ShadowMapDistance;
            stage float ExtinctionRatio;
        };

        override float ComputeColorIn(float4 positionWS, float3 eyeVS, float stepSize, int stepIndex)
        {
            //const float4 ScreenLimits = float4(-1, -1, 1, 1);
            float3 lightResult = 0;
            float3 sigmaT = ComputeExtinction(positionWS);
            float3 sigmaS = ComputeInScattering(positionWS);
            float3 stepExtinction = exp(-sigmaT * stepSize);

            // Just because some shadow groups use some of these streams, clear them for now
            ResetLightStream();
            streams.NdotL = 1;
            streams.normalWS = float3(0,1,0);
            streams.lightPositionWS = LightPosition;
            streams.lightDirectionWS = LightDirection;

            float atten = attenuation.Compute(positionWS);
            lightResult = stepExtinction * sigmaS * stepSize * shadowGroup.ComputeShadow(positionWS.xyz, 0) * atten;

            //if (all(screenPosition > ShadowTextureFactor.xy) && all(screenPosition < ShadowTextureFactor.zw))
            //{
            //    float weight = 0;
            //    // Simple 2x2 PCF
            //    for(int j = 0; j < 4; j++)
            //    {
            //        float shadowMapDepth = Texture1.SampleLevel(PointSampler, screenPosition.xy, 0.0, int2(j&2, j/2)).x;
            //        if (positionDepth < shadowMapDepth) 
            //        {
            //            weight += 1.0/4.0f;
            //        }
            //    }
            //    lightResult = stepExtinction * sigmaS * stepSize * weight;
            //}

            return lightResult;
        }

        float ComputeInScattering(float3 positionVS)
        {
            return ComputeDensity(positionVS) * ExtinctionFactor * ExtinctionRatio;
        }

        float ComputeDensity(float positionVS)
        {
            return DensityFactor;
        }

        float ComputeExtinction(float positionVS)
        {
            return ComputeDensity(positionVS) * ExtinctionFactor;
        }
    };
}