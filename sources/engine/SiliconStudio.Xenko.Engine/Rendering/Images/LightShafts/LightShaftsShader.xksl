// Copyright (c) 2014-2017 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Xenko.Rendering.Images
{
    shader LightShaftsShader : ImageEffectShader, ShadowMapCommon<PerFrame>, PostEffectBoundingRay<0, 0, 16>
    {
        cbuffer PerFrame
        {
            // World to shadow matrix
            stage matrix ShadowViewProjection;

            // Shadow map boundary for the current shadow map in the shadow atlas
            stage float4 ShadowTextureFactor;

            [Color]
            stage float3 LightColor;
        
            // Light position (if applicable)
            stage float3 ShadowLightOffset;
            // Light direction (if applicable)
            stage float3 ShadowLightDirection;

            stage float ExtinctionFactor;
            stage float DensityFactor;

            // Unused
            stage float ShadowMapDistance;
            stage float ExtinctionRatio;
        };

        override float3 ComputeColorIn(float4 positionWS, float3 eyeVS, float stepSize, int stepIndex)
        {
            const float4 ScreenLimits = float4(-1, -1, 1, 1);
            float3 lightResult = 0;
            float3 sigmaT = ComputeExtinction(positionWS);
            float3 sigmaS = ComputeInScattering(positionWS);
            float3 stepExtinction = exp(-sigmaT * stepSize);

            float4 positionLS = mul(positionWS, ShadowViewProjection);
            float positionDepth = dot(ShadowLightDirection, positionWS - ShadowLightOffset) / ShadowMapDistance;
            float2 screenPosition = positionLS.xy / positionLS.w;

            positionDepth = positionLS.z / positionLS.w;

            if (all(screenPosition > ShadowTextureFactor.xy) && all(screenPosition < ShadowTextureFactor.zw) )
            {
                float weight = 0;
                // Simple 2x2 PCF
                for(int j = 0; j < 4; j++)
                {
                    float shadowMapDepth = Texture1.SampleLevel(PointSampler, screenPosition.xy, 0.0, int2(j&2, j/2)).x;
                    if (positionDepth < shadowMapDepth) 
                    {
                        weight += 1.0/4.0f;
                    }
                }
                lightResult = stepExtinction * sigmaS * stepSize * weight;
            }
            return lightResult;
        }

        float3 ComputeInScattering(float3 positionVS)
        {
            return ComputeDensity(positionVS) * ExtinctionFactor * ExtinctionRatio;
        }

        float ComputeDensity(float positionVS)
        {
            return DensityFactor;
        }

        float3 ComputeExtinction(float positionVS)
        {
            return ComputeDensity(positionVS) * ExtinctionFactor;
        }
    };
}