// Copyright (c) 2014-2017 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

/// <remarks>
/// Debug: generic bool - enables debug mode, which highlights the areas where light shafts are generated.
/// IsZReverse: generic bool - swaps minz and max z.
/// NbSteps: generic int - number of iterations.
/// </remarks>
shader PostEffectBoundingRay<bool Debug, bool IsZReverse, int NbSteps> 
    : ImageEffectShader, DepthBase, Transformation, Camera, Utilities, Global, PositionStream4
{
    float ComputeColorOut() 
    {
        return 0;
    }

    float ComputeColorIn(float4 positionS, float3 eyeVS, float stepSize, int stepIndex) 
    {
        return 0;
    }

    float RayStepJitter(float3 positionVS, float stepSize) 
    {
        return stepSize * Math.FastRandom(int(positionVS.x * 100 + positionVS.y * 6007 * 100));
    }

    void ComputeDirection(inout float3 positionVS, inout float3 eyeVS, float minDistance, float maxDistance, float stepSize) 
    {
        // Place positionVS on background of boundingbox
        positionVS = -(maxDistance + RayStepJitter(positionVS, stepSize)) * eyeVS;
    }

    float ComputeFinalColor(float lightAcc) 
    {
        return float4(lightAcc.xxx, 1.0);
    }

    stage override void PSMain()
    {
        // minmax.x = min
        // minmax.y = max
        float2 minmax = Texture0.Sample(PointSampler, streams.TexCoord).xy;
        if (IsZReverse)
            minmax.xy = minmax.yx;

        // Need at least a maximum value for this pixel to be contained in the bounding box
        if(minmax.y < 1)
        {   
            float bbNearDistance = ComputeDepthFromZProj(minmax.x);
            float bbFarDistance = ComputeDepthFromZProj(minmax.y);

            // Clamp actual starting distance to 0 in case we only have a max
            if(minmax.x <= 0)
                bbNearDistance = 0; 

            float currentDepth = GetZProjDepthFromUV(streams.TexCoord.xy);

            float4 positionClipSpace = float4((1.0 - streams.TexCoord.xy * 2.0) * float2(-1.0f, 1.0f), currentDepth, 1.0f);
            float4 positionVS4 = mul(positionClipSpace, ProjectionInverse);
            float3 positionVS = positionVS4.xyz / positionVS4.w;
            float3 eyeVS = -normalize(positionVS);

            float3 lightResult = 0.0f;

            float currentDistance = -positionVS.z;

            float minDistance = bbNearDistance;
            float maxDistance = min(bbFarDistance, currentDistance);
            float stepSize = (maxDistance - minDistance) / (float)NbSteps;

            // Expected by the directional shadow map to compute the cascades
            streams.DepthVS = minDistance;
            if(maxDistance > minDistance)
            {
                // Recalculate max distance by jittering the length of the ray to avoid banding artefacts
                stepSize = (maxDistance - minDistance) / (float)NbSteps;

                // Compute direction
                ComputeDirection(positionVS, eyeVS, minDistance, maxDistance, stepSize);

                for(int i = 0; i < NbSteps; i++) 
                {
                    float4 positionWS = mul(float4(positionVS, 1.0), ViewInverse);
                    lightResult += this.ComputeColorIn(positionWS, eyeVS, stepSize, i);
                    positionVS += stepSize * eyeVS;
                    streams.DepthVS += stepSize;
                }
            }

            streams.ColorTarget = ComputeFinalColor(lightResult);

            // In debug mode, output just the volume depth of this pixel
            if (Debug)
                streams.ColorTarget = maxDistance - minDistance;
        }
        else // Outside the bounding box
        {
            if (Debug)
                streams.ColorTarget = 0;
            else
                streams.ColorTarget = this.ComputeColorOut();
        }
    }
};
