// Copyright (c) 2014-2017 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

/// <remarks>
/// SampleCount: generic int - number of iterations.
/// Animate: generic bool - animate jitter
/// </remarks>
shader PostEffectBoundingRay<int SampleCount, bool Animated> 
    : ImageEffectShader, DepthBase, Transformation, Camera, Utilities, Global, PositionStream4
{
    cbuffer PerFrame
    {
        // (0,0,0) in view space projected into world space
        stage float3 ViewBase;
        // Offset of '(1,0,0) in view space projected into world space' from ViewBase
        stage float3 ViewRight;
        // Offset of '(0,1,0) in view space projected into world space' from ViewBase
        stage float3 ViewUp;
    }

    float ComputeColorOut() 
    {
        return 0;
    }

    float ComputeColorIn(float4 positionWS, float stepSize, int stepIndex) 
    {
        return 0;
    }

    float RayStepJitter(float2 input, float stepSize) 
    {
        if(Animated)
        {
            return stepSize * Math.FastRandom(int(input.x * 10000 + input.y * 6007 * 10000 + Time * 1000000));
        }
        return stepSize * Math.FastRandom(int(input.x * 10000 + input.y * 6007 * 10000));
    }

    float ComputeFinalColor(float lightAcc) 
    {
        return float4(lightAcc.xxx, 1.0);
    }

    stage override void PSMain()
    {
        // minmax.x = min
        // minmax.y = max
        float2 minmax = Texture0.Sample(PointSampler, streams.TexCoord).xy;

        // Need at least a maximum value for this pixel to be contained in the bounding box
        if(minmax.y < 1)
        {   
            float bbNearDistance = ComputeDepthFromZProj(minmax.x);
            float bbFarDistance = ComputeDepthFromZProj(minmax.y);

            // Clamp actual starting distance to 0 in case we only have a max
            if(minmax.x <= 0)
                bbNearDistance = 0; 

             // Compute world space ray
            float2 ndc = streams.TexCoord * 2.0f - 1.0f;
            ndc.y = -ndc.y;
            float3 traceTarget = ViewBase;
            traceTarget += ViewRight * ndc.x;
            traceTarget += ViewUp * ndc.y;
            float4 directionWS = float4(normalize(traceTarget - Eye),0);

            float3 lightResult = 0.0f;

            float currentDistance = ComputeDepthFromUV(streams.TexCoord);

            float minDistance = bbNearDistance;
            float maxDistance = min(bbFarDistance, currentDistance);
            float stepSize = (maxDistance - minDistance) / (float)SampleCount;

            // Expected by the directional shadow map to compute the cascades
            streams.DepthVS = minDistance;
            if(maxDistance > minDistance)
            {
                // Recalculate max distance by jittering the length of the ray to avoid banding artefacts
                stepSize = (maxDistance - minDistance) / (float)SampleCount;

                // Starting position
                float4 positionWS = Eye + (minDistance + RayStepJitter(streams.TexCoord, stepSize)) * directionWS;

                for(int i = 0; i < SampleCount; i++) 
                {
                    lightResult += this.ComputeColorIn(positionWS, stepSize, i);
                    positionWS.xyz += stepSize * directionWS;
                    streams.DepthVS += stepSize;
                }
            }

            streams.ColorTarget = ComputeFinalColor(lightResult);
        }
        else // Outside the bounding box
        {
            streams.ColorTarget = this.ComputeColorOut();
        }
    }
};
